#!/bin/bash
set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DOTFILES_DIR="$SCRIPT_DIR"
CONFIG_FILE="$DOTFILES_DIR/config.yaml"

# Helper functions
log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Copy system defaults from /etc/skel
copy_from_skel() {
    local filename="$1"
    local skel_file="/etc/skel/$filename"
    local target_file="$HOME/$filename"
    
    if [ -f "$skel_file" ]; then
        log_info "Copying system default: $skel_file -> $target_file"
        cp "$skel_file" "$target_file"
        log_success "Restored $filename from system defaults"
    else
        log_warning "System default not found: $skel_file"
        return 1
    fi
}

# Create minimal gitconfig if no system default exists
create_minimal_gitconfig() {
    log_info "Creating minimal .gitconfig..."
    
    cat > "$HOME/.gitconfig" << 'EOF'
[user]
    name = Your Name
    email = your.email@example.com
[core]
    editor = nano
[init]
    defaultBranch = main
EOF
    
    log_success "Minimal .gitconfig created"
    log_warning "Please update your name and email in ~/.gitconfig"
}

# Reset dotfiles to system defaults
reset_to_defaults() {
    log_info "Resetting dotfiles to system defaults..."
    
    # Remove dotfiles symlinks and replace with defaults
    local files_to_reset=(
        "$HOME/.bashrc"
        "$HOME/.bash_aliases"
        "$HOME/.gitconfig"
    )
    
    for file in "${files_to_reset[@]}"; do
        if [ -L "$file" ]; then
            local link_target=$(readlink "$file")
            if [[ "$link_target" == "$DOTFILES_DIR"* ]]; then
                log_info "Removing dotfiles symlink: $file"
                rm "$file"
                
                # Create appropriate default file
                case "$file" in
                    "$HOME/.bashrc")
                        if ! copy_from_skel ".bashrc"; then
                            log_warning "Could not copy .bashrc from /etc/skel"
                            log_info "Your shell may not work properly without .bashrc"
                        fi
                        ;;
                    "$HOME/.gitconfig")
                        if ! copy_from_skel ".gitconfig"; then
                            create_minimal_gitconfig
                        fi
                        ;;
                    "$HOME/.bash_aliases")
                        copy_from_skel ".bash_aliases" || log_info "No system default for .bash_aliases"
                        ;;
                esac
            fi
        elif [ -f "$file" ]; then
            log_info "File $file exists but is not a dotfiles symlink - leaving unchanged"
        fi
    done
    
    # Clean up PATH modifications
    clean_path_modifications
    
    log_success "Reset to defaults completed!"
}

# List available backup directories
list_backups() {
    log_info "Available backup directories:"
    find "$HOME" -maxdepth 1 -name ".dotfiles-backup-*" -type d 2>/dev/null | sort -r | while read backup_dir; do
        local timestamp=$(basename "$backup_dir" | sed 's/.dotfiles-backup-//')
        echo "  $backup_dir (created: $timestamp)"
    done
}

# Restore from backup
restore_from_backup() {
    local backup_dir="$1"
    
    if [ ! -d "$backup_dir" ]; then
        log_error "Backup directory not found: $backup_dir"
        return 1
    fi
    
    log_info "Restoring files from: $backup_dir"
    
    # Remove current dotfiles symlinks first
    local files_to_restore=(
        "$HOME/.bashrc"
        "$HOME/.bash_aliases" 
        "$HOME/.gitconfig"
    )
    
    for file in "${files_to_restore[@]}"; do
        if [ -L "$file" ]; then
            local link_target=$(readlink "$file")
            if [[ "$link_target" == "$DOTFILES_DIR"* ]]; then
                log_info "Removing dotfiles symlink: $file"
                rm "$file"
            fi
        fi
    done
    
    # Restore files from backup
    for backup_file in "$backup_dir"/*; do
        if [ -f "$backup_file" ]; then
            local filename=$(basename "$backup_file")
            local target="$HOME/.$filename"
            
            log_info "Restoring: $target"
            cp "$backup_file" "$target"
        fi
    done
    
    # Clean up PATH modifications
    clean_path_modifications
    
    log_success "Files restored from backup successfully"
}

# Main reset function
main_reset() {
    log_info "Dotfiles Reset to Defaults"
    echo
    
    # Check for available backups
    local backup_count=$(find "$HOME" -maxdepth 1 -name ".dotfiles-backup-*" -type d 2>/dev/null | wc -l)
    
    log_info "Choose reset option:"
    echo "  1) Reset to system defaults (from /etc/skel)"
    echo "  2) Restore from backup (if available)"
    echo "  3) Cancel"
    echo
    
    if [ "$backup_count" -gt 0 ]; then
        log_info "Found $backup_count backup directory(ies) available"
    else
        log_warning "No backup directories found - only option 1 available"
    fi
    echo
    
    read -p "Enter choice (1-3): " -n 1 -r
    echo
    
    case $REPLY in
        1)
            log_info "Resetting to system defaults..."
            reset_to_defaults
            ;;
        2)
            if [ "$backup_count" -gt 0 ]; then
                list_backups
                echo
                echo "Enter the full path to the backup directory:"
                read -r backup_path
                if [ -n "$backup_path" ]; then
                    restore_from_backup "$backup_path"
                else
                    log_error "No backup path provided"
                    exit 1
                fi
            else
                log_error "No backups available"
                exit 1
            fi
            ;;
        3)
            log_info "Reset cancelled"
            exit 0
            ;;
        *)
            log_error "Invalid choice"
            exit 1
            ;;
    esac
}

# Clean up PATH modifications
clean_path_modifications() {
    log_info "Cleaning up PATH modifications..."
    
    if [ -f "$HOME/.bashrc" ]; then
        # Remove the ~/.local/bin PATH addition we added
        if grep -q "# Add ~/.local/bin to PATH for user-installed tools" "$HOME/.bashrc"; then
            log_info "Removing ~/.local/bin PATH modification from ~/.bashrc"
            # Create a temporary file without our PATH modification
            awk '
                /# Add ~\/\.local\/bin to PATH for user-installed tools/ { skip=1; next }
                /export PATH="\$HOME\/\.local\/bin:\$PATH"/ && skip { skip=0; next }
                !skip
            ' "$HOME/.bashrc" > "$HOME/.bashrc.tmp"
            mv "$HOME/.bashrc.tmp" "$HOME/.bashrc"
        fi
    fi
}



# Main function
main() {
    log_info "Dotfiles Reset Tool"
    log_info "Dotfiles directory: $DOTFILES_DIR"
    
    # Check if we're in the right directory
    if [ ! -f "$CONFIG_FILE" ]; then
        log_error "Config file not found at: $CONFIG_FILE"
        log_error "Make sure you're running this from the dotfiles directory."
        exit 1
    fi
    
    case "${1:-}" in
        --defaults|-d)
            reset_to_defaults
            ;;
        --list-backups|-l)
            list_backups
            ;;
        --restore)
            if [ -z "$2" ]; then
                log_error "Please specify backup directory path"
                exit 1
            fi
            restore_from_backup "$2"
            ;;
        --help|-h)
            echo "Usage: $0 [options]"
            echo "Options:"
            echo "  --defaults, -d       Reset to system defaults (non-interactive)"
            echo "  --list-backups, -l   List available backup directories"
            echo "  --restore <path>     Restore from specific backup directory"
            echo "  --help, -h           Show this help message"
            echo ""
            echo "Default behavior (no options): Interactive reset with menu"
            exit 0
            ;;
        *)
            main_reset
            ;;
    esac
}

main "$@"