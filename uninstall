#!/bin/bash
set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DOTFILES_DIR="$SCRIPT_DIR"
CONFIG_FILE="$DOTFILES_DIR/config.yaml"

# Helper functions
log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Parse YAML config (same as install script)
get_config() {
    local key="$1"
    if [ -f "$CONFIG_FILE" ]; then
        if [[ "$key" == *.* ]]; then
            local section=$(echo "$key" | cut -d. -f1)
            local subkey=$(echo "$key" | cut -d. -f2-)
            awk -v section="$section" -v subkey="$subkey" '
                /^[a-zA-Z]/ { current_section = $1; gsub(/:/, "", current_section) }
                current_section == section && $0 ~ "^  " subkey ":" {
                    gsub(/^  /, ""); gsub(subkey ":", ""); gsub(/^ */, ""); gsub(/"/, ""); gsub(/#.*/, ""); gsub(/[ \t]*$/, ""); print; exit
                }
            ' "$CONFIG_FILE"
        else
            grep -E "^\s*${key}:" "$CONFIG_FILE" | sed 's/.*: *//' | sed 's/#.*//' | tr -d '"' | sed 's/[ \t]*$//' | head -1
        fi
    fi
}

is_module_enabled() {
    local module="$1"
    local enabled=$(get_config "modules.${module}")
    [ "$enabled" = "true" ]
}

# Find and list backup directories
list_backups() {
    log_info "Available backup directories:"
    find "$HOME" -maxdepth 1 -name ".dotfiles-backup-*" -type d 2>/dev/null | sort -r | while read backup_dir; do
        local timestamp=$(basename "$backup_dir" | sed 's/.dotfiles-backup-//')
        echo "  $backup_dir (created: $timestamp)"
    done
}

# Restore from backup
restore_backup() {
    local backup_dir="$1"
    
    if [ ! -d "$backup_dir" ]; then
        log_error "Backup directory not found: $backup_dir"
        return 1
    fi
    
    log_info "Restoring files from: $backup_dir"
    
    for backup_file in "$backup_dir"/*; do
        if [ -f "$backup_file" ]; then
            local filename=$(basename "$backup_file")
            local target="$HOME/.$filename"
            
            if [ -L "$target" ]; then
                log_info "Removing symlink: $target"
                rm "$target"
            fi
            
            log_info "Restoring: $target"
            cp "$backup_file" "$target"
        fi
    done
    
    log_success "Backup restored successfully"
}

# Remove symlinks created by dotfiles
remove_symlinks() {
    log_info "Removing dotfiles symlinks..."
    
    local files_to_check=(
        "$HOME/.bashrc"
        "$HOME/.bash_aliases"
        "$HOME/.gitconfig"
    )
    
    for file in "${files_to_check[@]}"; do
        if [ -L "$file" ]; then
            local link_target=$(readlink "$file")
            if [[ "$link_target" == "$DOTFILES_DIR"* ]]; then
                log_info "Removing symlink: $file -> $link_target"
                rm "$file"
                
                # For critical files like .bashrc, create a basic replacement if no backup will be restored
                if [[ "$file" == "$HOME/.bashrc" ]]; then
                    create_basic_bashrc_if_needed "$file"
                fi
            fi
        fi
    done
}

# Create a basic .bashrc if none exists after symlink removal
create_basic_bashrc_if_needed() {
    local bashrc_path="$1"
    
    if [ ! -f "$bashrc_path" ]; then
        log_warning "No .bashrc found after symlink removal"
        log_info "Creating basic .bashrc to prevent shell issues"
        
        cat > "$bashrc_path" << 'EOF'
# ~/.bashrc: executed by bash(1) for non-login shells.

# If not running interactively, don't do anything
case $- in
    *i*) ;;
      *) return;;
esac

# Basic history settings
HISTCONTROL=ignoreboth
HISTSIZE=1000
HISTFILESIZE=2000
shopt -s histappend

# Check window size after each command
shopt -s checkwinsize

# Enable color support for ls and add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    alias grep='grep --color=auto'
fi

# Some more ls aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'

# Enable programmable completion features
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi
EOF
        
        log_success "Created basic .bashrc"
        log_warning "This is a minimal .bashrc - consider restoring from backup if available"
    fi
}

# Uninstall tools (optional)
uninstall_tools() {
    log_warning "Tool uninstallation is optional and may affect other applications"
    read -p "Do you want to uninstall tools installed by dotfiles? (y/N): " -n 1 -r
    echo
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        log_info "Uninstalling tools..."
        
        # Remove tools from ~/.local/bin if they exist
        local local_tools=(
            "$HOME/.local/bin/goto"
            "$HOME/.local/bin/btm"
        )
        
        for tool in "${local_tools[@]}"; do
            if [ -f "$tool" ]; then
                log_info "Removing: $tool"
                rm "$tool"
            fi
        done
        
        # Remove fzf
        if [ -d "$HOME/.fzf" ]; then
            log_info "Removing fzf installation..."
            rm -rf "$HOME/.fzf"
        fi
        
        # Note about system-installed tools
        log_warning "System-installed tools (goto, bottom, starship) may still be present"
        log_info "Use your package manager to remove them if desired"
    fi
}

# Clean up PATH modifications
clean_path_modifications() {
    log_info "Cleaning up PATH modifications..."
    
    if [ -f "$HOME/.bashrc" ]; then
        # Remove the ~/.local/bin PATH addition we added
        if grep -q "# Add ~/.local/bin to PATH for user-installed tools" "$HOME/.bashrc"; then
            log_info "Removing ~/.local/bin PATH modification from ~/.bashrc"
            # Create a temporary file without our PATH modification
            awk '
                /# Add ~\/\.local\/bin to PATH for user-installed tools/ { skip=1; next }
                /export PATH="\$HOME\/\.local\/bin:\$PATH"/ && skip { skip=0; next }
                !skip
            ' "$HOME/.bashrc" > "$HOME/.bashrc.tmp"
            mv "$HOME/.bashrc.tmp" "$HOME/.bashrc"
        fi
    fi
}

# Interactive uninstall
interactive_uninstall() {
    log_info "Interactive dotfiles uninstall"
    echo
    
    # Check for existing backups first
    local backup_count=$(find "$HOME" -maxdepth 1 -name ".dotfiles-backup-*" -type d 2>/dev/null | wc -l)
    
    # Show what will be removed and safety info
    log_info "This will:"
    echo "  - Remove dotfiles symlinks (.bashrc, .gitconfig, etc.)"
    echo "  - Optionally restore from backup"
    echo "  - Optionally remove installed tools"
    echo "  - Clean up PATH modifications"
    echo
    
    if [ "$backup_count" -gt 0 ]; then
        log_info "Found $backup_count backup directory(ies) available for restoration"
    else
        log_warning "No backup directories found!"
        log_warning "A basic .bashrc will be created if your current one is a dotfiles symlink"
    fi
    echo
    
    read -p "Continue with uninstall? (y/N): " -n 1 -r
    echo
    
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "Uninstall cancelled"
        exit 0
    fi
    
    # Ask about backup restoration BEFORE removing symlinks
    if [ "$backup_count" -gt 0 ]; then
        list_backups
        echo
        read -p "Do you want to restore from a backup? (y/N): " -n 1 -r
        echo
        
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            echo "Enter the full path to the backup directory:"
            read -r backup_path
            if [ -n "$backup_path" ]; then
                restore_backup "$backup_path"
                log_info "Files restored from backup before removing symlinks"
            fi
        fi
    fi
    
    # Remove symlinks (this will create basic .bashrc if needed)
    remove_symlinks
    
    # Clean up PATH modifications
    clean_path_modifications
    
    # Ask about tool removal
    uninstall_tools
    
    log_success "Dotfiles uninstall completed!"
    log_info "Please restart your shell or run: source ~/.bashrc"
}

# Quick uninstall (non-interactive)
quick_uninstall() {
    log_info "Quick dotfiles uninstall (non-interactive)"
    
    remove_symlinks
    clean_path_modifications
    
    log_success "Dotfiles uninstalled (symlinks removed, PATH cleaned)"
    log_info "Backups were not restored. Use --interactive for more options."
}

# Main function
main() {
    log_info "Dotfiles Uninstaller"
    log_info "Dotfiles directory: $DOTFILES_DIR"
    
    # Check if we're in the right directory
    if [ ! -f "$CONFIG_FILE" ]; then
        log_error "Config file not found at: $CONFIG_FILE"
        log_error "Make sure you're running this from the dotfiles directory."
        exit 1
    fi
    
    case "${1:-}" in
        --interactive|-i)
            interactive_uninstall
            ;;
        --quick|-q)
            quick_uninstall
            ;;
        --list-backups|-l)
            list_backups
            ;;
        --restore)
            if [ -z "$2" ]; then
                log_error "Please specify backup directory path"
                exit 1
            fi
            restore_backup "$2"
            ;;
        --help|-h)
            echo "Usage: $0 [options]"
            echo "Options:"
            echo "  --interactive, -i    Interactive uninstall with all options"
            echo "  --quick, -q          Quick uninstall (remove symlinks only)"
            echo "  --list-backups, -l   List available backup directories"
            echo "  --restore <path>     Restore from specific backup directory"
            echo "  --help, -h           Show this help message"
            exit 0
            ;;
        *)
            interactive_uninstall
            ;;
    esac
}

main "$@"